# OAuth 2.0 認可サーバー 要件定義書

## 1. 概要

このドキュメントは、Go 言語で実装される OAuth 2.0 認可サーバーの要件を定義します。このサーバーは、クライアントアプリケーションがユーザーの代わりに保護されたリソースにアクセスするための認可を提供します。

## 2. 機能要件

### 2.1 サポートする認可フロー

以下の OAuth 2.0 認可フローをサポートする必要があります。

- **認可コードフロー (Authorization Code Grant):** 最も一般的で安全なフロー。サーバーサイドアプリケーションに適しています。
- **インプリシットフロー (Implicit Grant):** アクセストークンを直接クライアントに発行するフロー。主にシングルページアプリケーション（SPA）で使用されますが、セキュリティ上の懸念から非推奨となりつつあります。（オプション）
- **クライアントクレデンシャル フロー (Client Credentials Grant):** クライアント自身の認証情報を使用してアクセストークンを取得するフロー。クライアントがリソースオーナーである場合に適しています。
- **リソースオーナーパスワードクレデンシャル フロー (Resource Owner Password Credentials Grant):** ユーザーのパスワードを直接使用してアクセストークンを取得するフロー。信頼できるクライアントのみに限定すべきです。（オプション）

### 2.2 クライアント管理

- クライアントアプリケーションの登録、更新、削除機能を提供する必要があります。
- 各クライアントには一意のクライアント ID とクライアントシークレットが割り当てられます。
- クライアントごとに許可されるリダイレクト URI、認可フロー、スコープを設定できる必要があります。

### 2.3 トークン管理

- **アクセストークン:** 保護されたリソースへのアクセスに使用されるトークン。
  - 発行、検証、失効機能が必要です。
  - 有効期限を設定できる必要があります。
  - JWT (JSON Web Token) 形式をサポートする必要があります。
- **リフレッシュトークン:** 新しいアクセストークンを取得するために使用されるトークン。
  - 発行、検証、失効機能が必要です。
  - アクセストークンよりも長い有効期限を設定できる必要があります。
  - リフレッシュトークンの再利用ポリシー（例: 一度使用したら失効）を設定できる必要があります。

### 2.4 エンドポイント

以下の HTTP エンドポイントを提供する必要があります。

- **認可エンドポイント (`/oauth/authorize`):** ユーザーに認可を要求し、認可コードまたはアクセストークン（インプリシットフローの場合）を発行します。
- **トークンエンドポイント (`/oauth/token`):** 認可コード、リフレッシュトークン、またはクライアント/ユーザーのクレデンシャルと引き換えにアクセストークンおよびリフレッシュトークンを発行します。
- **トークン情報エンドポイント (`/oauth/introspect`):** アクセストークンまたはリフレッシュトークンの有効性や関連情報を検証します。（オプション、RFC 7662）
- **トークン失効エンドポイント (`/oauth/revoke`):** アクセストークンまたはリフレッシュトークンを失効させます。（オプション、RFC 7009）
- **クライアント管理エンドポイント (`/oauth/clients`):** クライアントの登録、更新、削除を行います。（管理用 API）

### 2.5 スコープ管理

- リソースへのアクセス権限を定義するスコープをサポートする必要があります。
- クライアントはリクエスト時に必要なスコープを指定できます。
- ユーザーはクライアントに許可するスコープを選択できます。
- 発行されるアクセストークンには許可されたスコープが含まれます。

## 3. 非機能要件

### 3.1 セキュリティ

- **TLS/HTTPS:** すべてのエンドポイントは TLS/HTTPS 経由でのみアクセス可能である必要があります。
- **クライアント認証:** トークンエンドポイントでは、クライアント ID とクライアントシークレットを使用したクライアント認証（例: Basic 認証）をサポートする必要があります。
- **トークンセキュリティ:**
  - アクセストークンは短命である必要があります。
  - リフレッシュトークンは安全に保管される必要があります。
  - トークンは推測困難である必要があります。
  - JWT を使用する場合、適切な署名アルゴリズム（例: RS256）を使用し、鍵管理を適切に行う必要があります。
- **CSRF 保護:** 認可エンドポイントでは、`state`パラメータを使用した CSRF（クロスサイトリクエストフォージェリ）攻撃からの保護を実装する必要があります。
- **リダイレクト URI 検証:** 認可コードやトークンを送信する前に、リクエストされたリダイレクト URI が登録済みのものと一致するか検証する必要があります。
- **レート制限:** 不正なリクエストを防ぐために、エンドポイントへのレート制限を実装する必要があります。

### 3.2 パフォーマンス

- 各エンドポイントは、通常の負荷状況下で妥当な応答時間（例: 500ms 以内）を提供する必要があります。
- 多数のクライアントとトークンを効率的に処理できる必要があります。

### 3.3 拡張性

- 将来的に新しい認可フローや機能を追加できるように、モジュール化された設計である必要があります。
- データストレージ（クライアント情報、トークン情報など）を容易に切り替えられる設計である必要があります（例: インメモリ、データベース）。

### 3.4 信頼性

- サーバーは安定して稼働し、エラー発生時にも適切に処理およびログ記録を行う必要があります。

### 3.5 運用性

- 設定（ポート番号、トークン有効期限、鍵情報など）を外部ファイル（例: YAML）で管理できる必要があります。
- ログ出力機能を提供し、サーバーの状態やエラーを監視できるようにする必要があります。

## 4. 制約条件

- 実装言語は Go 言語とします。
- 関数型プログラミングの原則を可能な限り適用します。
- 外部ライブラリの利用は必要最小限に留めますが、標準ライブラリや広く使われている信頼性の高いライブラリ（例: JWT ライブラリ）の利用は許可します。

## 5. 将来的な拡張可能性

- OpenID Connect (OIDC) のサポート
- PKCE (Proof Key for Code Exchange) のサポート (RFC 7636)
- デバイス認可フロー (Device Authorization Grant) のサポート (RFC 8628)
- 高度なクライアント管理機能（例: 動的クライアント登録）
- データベース永続化のサポート（PostgreSQL, MySQL など）
- 分散環境でのスケーラビリティ向上
